
<!DOCTYPE html
  >
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja"><head><meta charset="UTF-8"/><title>SL7: Designing a Focused Visual State for Custom Silverlight Controls | WCAG 2.0 達成方法集
              </title><link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/2016/W3C-WG-NOTE.css"/><link rel="stylesheet" type="text/css" href="additional.css"/><link rel="stylesheet" type="text/css" href="slicenav.css"/></head><body class="slices toc-inline"><div id="masthead"><p class="logo"><a href="https://www.w3.org/"><img width="72" height="48" alt="W3C" src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C"/></a></p><p class="collectiontitle"><a href="Overview.html">WCAG 2.0 達成方法集</a></p></div><div id="skipnav"><p class="skipnav"><a href="#maincontent">Skip to Content (Press Enter)</a></p></div><a name="top"> </a><!-- TOP NAVIGATION BAR --><ul id="navigation"><li><strong><a href="Overview.html#contents" title="Table of Contents">目次</a></strong></li><li><strong><a href="intro.html" title="Introduction to Techniques for WCAG 2.0"><abbr title="Introduction">イントロダクション</abbr></a></strong></li><li><a title="SL6: Defining a UI Automation Peer for a Custom Silverlight Control" href="SL6.html"><strong>前: </strong>
        達成方法 SL6</a></li><li><a title="SL8: Displaying HelpText in Silverlight User Interfaces" href="SL8.html"><strong>次: </strong>
        達成方法 SL8</a></li></ul><div class="navtoc"><p>このページのコンテンツ:</p><ul id="navbar"><li><a href="#SL7-disclaimer">達成方法に関する重要な情報</a></li><li><a href="#SL7-applicability">適用 (対象)</a></li><li><a href="#SL7-description">解説</a></li><li><a href="#SL7-examples">事例</a></li><li><a href="#SL7-resources">参考リソース</a></li><li><a href="#SL7-related-techs">関連する達成方法</a></li><li><a href="#SL7-tests">検証</a></li></ul></div><div class="skiptarget"><a id="maincontent">-</a></div> <h1><a name="SL7" id="SL7"> </a>SL7: Designing a Focused Visual State for Custom Silverlight Controls</h1><div id="SL7-disclaimer"><h2>達成方法に関する重要な情報</h2><p>これらの達成方法 (参考) の使用法及び、それらが WCAG 2.0 達成基準 (規定) とどのように関係するかに関する重要な情報については、<a href="https://waic.jp/docs/UNDERSTANDING-WCAG20/understanding-techniques.html">WCAG 達成基準の達成方法を理解する</a>を参照のこと。適用 (対象) セクションは、その達成方法の範囲について説明しており、特定の技術に関する達成方法があるからといって、WCAG 2.0 を満たすコンテンツを作成する際に、常にその技術が使用可能であるわけではない。</p></div><div class="applicability"><h2 id="SL7-applicability">適用 (対象)</h2><div class="textbody"><ul><li><p> Microsoft Silverlight, versions 3 and greater </p></li><li><p> Silverlight managed programming model and Silverlight XAML </p></li></ul></div></div><div class="note"><p><em>訳注:</em> Silverlight は、2021 年 11 月にサポートを終了する計画が Microsoft 社より公表されている (<a href="https://support.microsoft.com/ja-jp/lifecycle/search/12905">Microsoft サポート - Silverlight のライフサイクルポリシー</a>)。</p><p>WAIC では、Silverlight に関する達成方法の翻訳を行っていないが、将来もその予定がないことに留意されたい。</p></div><p class="referenced">これは、次の達成基準に関連する達成方法である:</p><ul><li><a href="https://waic.jp/docs/WCAG20/Overview.html#navigation-mechanisms-focus-visible">
				達成基準 2.4.7 (フォーカスの可視化)</a><ul><li><a href="https://waic.jp/docs/WCAG20/quickref/#navigation-mechanisms-focus-visible">
						クイックリファレンス 2.4.7 (フォーカスの可視化)
					</a></li><li><a href="https://waic.jp/docs/UNDERSTANDING-WCAG20/navigation-mechanisms-focus-visible.html">
						達成基準 2.4.7 (フォーカスの可視化)を理解する
					</a></li></ul></li></ul><div class="ua-issues"><h2 class="small-head" id="ua10.7.1">ユーザエージェント及び支援技術によるサポート</h2><p><a href="./ua-notes/silverlight.html#SL7">SL7 に関するユーザエージェントサポートノート</a>を参照のこと。<a href="silverlight_notes.html">Silverlight Technology Notes</a>も参照。</p></div><h2 id="SL7-description">解説</h2><div class="textbody"><p>The objective of this technique is to build custom visual states for
    				custom controls that include visible focus indicators in the templates
    				and parts. </p><p>The default Silverlight core controls all indicate some type of visible
    				focus indication, through their default templates. For more information
    				on how Silverlight controls will generally supply a default visual
    				focus indicator, see <a href="https://msdn.microsoft.com/en-us/library/cc903954(VS.95).aspx">Focus
    					Overview on MSDN</a>. </p><p>Silverlight control skinning is enabled through a deliberate separation
    				of visible user interface design and control logic in the Silverlight
    				control model. Control authors expect that application authors might
    				reskin their control. But control authors should provide an initial
    				default set of states, templates, etc. so that application authors
    				have a good baseline of functionality to compare with their customization.
    				Defining visible focus states for all control parts is an example of
    				such baseline functionality. In order to make the visual focus state
    				customizable, the visual state should be associated with a name. Ideally
    				that name should have a human-readable meaning that hints at its purpose,
    				but the real reason for the name is that it connects the XAML-defined
    				template (which control consumers can change) with the control logic
    				defined by the control author (which control consumers cannot change).
    				Also, the visual names and groups in the XAML should be attributed
    				on the control class, to assist design tools. The best resource for
    				general information about Silverlight control customization is <a href="https://msdn.microsoft.com/en-us/library/cc278064%28v=VS.95%29.aspx">Silverlight
    					documentation on MSDN</a>. </p><div id="SL7_component_parts"><h4>Component Parts</h4><p>Some controls are created by assembling various component parts that
    					are already defined as controls either by the Silverlight run time
    					libraries or by third parties. That scenario is not really what this
    					technique is about, because in that case the focus behavior is already
    					defined by the component's template, and the control author can re-use
    					that behavior as-is or reskin it but still through the same named state
    					definition. This technique specifically addresses how to define a control
    					where the interactive surface has mouse and keyboard handling defined
    					at a lower level for the control as a whole. The actual focus region
    					is defined by the control author in that case, and the focus indicator
    					is also defined to match the behavior visually and functionally. </p></div><div id="SL7_focus_indicator_design"><h4>Design for Focus Indicators</h4><p>The general design principles for visual focus indicators are that
    					the indicators should apply a visual change to the focus region's exterior
    					margin. A common pattern is to deliberately define the visuals for
    					the control with a pre-existing blank margin for its layout slot; that
    					way when the focus indicator is applied, the focus indicator can fill
    					that margin. </p><p>The actual graphic for the visual focus indicator is typically a border
    					or shaped frame of a solid color brush with at least 1 pixel line thickness.
    					The color used for the border stands out visually from the underlying
    					control background or other elements of the control. The contrast between
    					brush for visual focus and the remainder of control should be a contrast
    					difference that is visible to users who do not distinguish the hue
    					of colors, but can distinguish the lightness/value. In many cases the
    					border is rectangular, to go along with the control's layout slot.
    					However, if the control's basic shape is a non-rectangular shape, sometimes
    					the focus indicator is designed to make a border around that shape.
    					An example of a default Silverlight control that is round and applies
    					an exterior round border as a focus indicator is a <a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.radiobutton%28VS.95%29.aspx">RadioButton</a>. </p><p>Most focus indicator designs change only the border and do not change
    					the main area of the control. One reason for this is that changes to
    					the main control are typically reserved for other interactive states
    					that also have a visual indicator. Specifically, controls need a visual
    					state that indicates that the mouse is over the control (this is termed
    					either MouseOver or Hover state). Controls that support activation
    					also have a visual state that provides feedback for activation. For
    					example, the default Silverlight <code>RepeatButton</code> changes
    					its <code>Background</code> gradient on the button field to be
    					darker blue value when the mouse is over the button, and changes to
    					an even darker value blue when the button is activated (either by clicking
    					the mouse or by pressing SPACE or ENTER with keyboard focus on the <code>RepeatButton</code>).
    					To see this behavior in a live sample, see <a href="http://samples.msdn.microsoft.com/Silverlight/SampleBrowser/index.htm#/?sref=System.Windows.Controls.RepeatButtonEx">RepeatButton
    						sample on MSDN</a>. </p></div><div id="SL7_focus_indicator_logic"><h4>Logic for Focus Indicators</h4><p>Typical logic is that the border to indicate focus is present in the
    					default template design, but with an initial value of Visibility=Collapsed.
    					Then, a visual state for focus is defined with a name that properly
    					indicates its purpose as text (example: "Focused"). In addition,
    					a state is needed that undoes whatever changes were applied for focus,
    					once focus moves to another element (for example,   "Unfocused").
    					For example, if the "Focused" state sets the value Visibility=Visible
    					on some element, the "Unfocused" state sets that value to
    					Collapsed again. Silverlight's visual state system also provides a
    					way to group related states with a factoring name (for example, "FocusStates").
    					For more information on state names and state groups in Silverlight
    					visual states, as well as learning how these states define a control
    					contract that any control consumers should follow if they reskin that
    					control, see <a href="https://msdn.microsoft.com/en-us/library/cc189093(VS.95).aspx">Customizing
    						the Appearance of an Existing Control by Using a ControlTemplate on
    						MSDN</a>. </p><p>The visual state system is designed to support visual transitions
    					to states, and for that reason the visual state system is closely coupled
    					with the Silverlight animation system. By animating the transition,
    					the visual appearance changes over a time interval. Typically, if transitions
    					are used, the time interval is short, one second or less. In the case
    					of focus indicators, it is typical to not use transitions and to instead
    					make a discrete change; otherwise, the state change might be interpreted
    					by users as a lag in interface response from their system. </p><p>The states themselves are designed in XAML, but are loaded and unloaded
    					through logic that the control author defines as part of their control
    					code. The control author does this by handling the appropriate events
    					that occur while the event scope applies to their control. For example,
    					to apply the "Focused" state, the control author handles
    					the <a href="https://msdn.microsoft.com/en-us/library/system.windows.uielement.gotfocus%28VS.95%29.aspx">GotFocus
    						event</a>. Rather than handle the event directly, the more common pattern
    					is to override a virtual method that acts as a prewired event handler, <a href="https://msdn.microsoft.com/en-us/library/system.windows.controls.control.ongotfocus%28v=VS.95%29.aspx">OnGotFocus</a>.
    					The centralized logic for visual state changes is the method <a href="https://msdn.microsoft.com/en-us/library/dd991369%28v=vs.110%29.aspx">GoToState</a>,
    					with one of the parameters to pass representing the XAML name of the
    					correct state to load from the XAML templates. Examples for all of
    					the APIs discussed here are available in the MSDN topic <a href="https://msdn.microsoft.com/en-us/library/cc278064(VS.95).aspx">Creating
    						a New Control by Creating a ControlTemplate</a>. </p></div><div id="SL7_silverlight_focus"><h4>Focus in Silverlight</h4><p>Focus in Silverlight is equivalent to the larger user interface and
    					application concept of keyboard focus. The element that has focus is
    					the element within the Silverlight object tree and programming model
    					that has first chance to process the Silverlight key events. As a more
    					tangible example that is user-centric, if a <code>TextBox</code> has
    					keyboard focus, then when the user presses keys on the keyboard, the
    					characters associated with the user's pressed keys (or possibly input
    					that is enabled by an assistive technology that can substitute for
    					key strokes) will appear in the <code>TextBox</code>. A user interface
    					element in Silverlight can obtain keyboard focus in one of three ways: </p><ol class="enumar"><li><p> The user uses the Silverlight tab sequence to traverse into the
    					Silverlight content and to focus a specific control. </p></li><li><p> The Silverlight application's logic calls the Focus() method programmatically
    						to force focus to a control. </p></li><li><p> The user performs some other action, for example uses the mouse
    							to click on a control. That control's specific logic handles the
    							Silverlight input event and uses that event as stimulus to call Focus()
    							on that control. The difference between this case and the above case
    							is that the behavior is typically built-in to that control's runtime
    							behavior, and does not require each application author to call Focus()
    							in application code. </p></li></ol></div></div><h2 class="small-head" id="SL7-examples">事例</h2><h3 class="small-head" id="SL7-ex1">事例 1: Visible focus indicator as a style and state</h3><div class="example"><div class="textbody"><p>The following is the XAML that defines the basic (normal) control
    						template. This control is simple: it has a yellow circle graphic, which
    						overlays a red circle edge when the control is focused. The circle
    						edge is defined by the "FocusVisual" element in the composition,
    						and is initially Visibility=Collapsed (the expected visual state prior
    						to being focused). </p><div class="code"><pre><code>&lt;ResourceDictionary
   xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
   xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
   xmlns:local="clr-namespace:FocusVisualCustomControl"
&gt;
   &lt;Style TargetType="local:SampleControl"&gt;
       &lt;Setter Property="Template"&gt;
           &lt;Setter.Value&gt;
               &lt;ControlTemplate TargetType="local:SampleControl"&gt;
                   &lt;Grid x:Name="ControlRoot"&gt;
                       &lt;Ellipse x:Name="CoinGraphic"
                         Fill="Orange"
                         Width="{TemplateBinding Width}"
                         Height="{TemplateBinding Height}"
                       /&gt;
                       &lt;Ellipse x:Name="FocusVisual"
                         Visibility="Collapsed"
                         Stroke="Red"
                         StrokeThickness="1"
                         Width="{TemplateBinding FrameworkElement.Width}"
                         Height="{TemplateBinding FrameworkElement.Height}"
                       /&gt;
                   &lt;/Grid&gt;
               &lt;/ControlTemplate&gt;
           &lt;/Setter.Value&gt;
       &lt;/Setter&gt;
   &lt;/Style&gt;
&lt;/ResourceDictionary&gt;
</code></pre></div><p>The following is the specific visual state portion. Note how the
    						visual state includes an <code>ObjectAnimation</code> with discrete
    						keyframes for hard transition between Visible and Collapsed, targeting
    						the element "FocusVisual" in the composition shown in the
    						previous XAML. </p><div class="code"><pre><code>                       &lt;VisualStateManager.VisualStateGroups&gt;
                           &lt;VisualStateGroup x:Name="FocusStates"&gt;
                               &lt;VisualState x:Name="Unfocused"/&gt;
                               &lt;VisualState x:Name="Focused"&gt;
                                   &lt;Storyboard&gt;
                                       &lt;ObjectAnimationUsingKeyFrames
                                         Storyboard.TargetName="FocusVisual" 
                                         Storyboard.TargetProperty="Visibility" Duration="0"&gt;
                                           &lt;DiscreteObjectKeyFrame KeyTime="0"&gt;
                                               &lt;DiscreteObjectKeyFrame.Value&gt;
                                                   &lt;Visibility&gt;Visible&lt;/Visibility&gt;
                                               &lt;/DiscreteObjectKeyFrame.Value&gt;
                                           &lt;/DiscreteObjectKeyFrame&gt;
                                       &lt;/ObjectAnimationUsingKeyFrames&gt;
                                   &lt;/Storyboard&gt;
                               &lt;/VisualState&gt;
                           &lt;/VisualStateGroup&gt;
                       &lt;/VisualStateManager.VisualStateGroups&gt;
                       </code></pre></div><p>The following is control logic in the control class that responds
    						to the focus-related events and switches visual states in response.
    						In this particular example, "Unfocused" is a state without
    						a definition. Switching to the definitionless state has the effect
    						of reverting to the default state, which in the case of this design
    						is intentional. Alternatively, authors could make specific template
    						changes that revert any animation that applied to the focused state. </p><div class="code"><pre><code>       protected override void OnGotFocus(RoutedEventArgs e)
       {
           base.OnGotFocus(e);
           VisualStateManager.GoToState(this, "Focused", false);
       }
       protected override void OnLostFocus(RoutedEventArgs e)
       {
           base.OnLostFocus(e);
           VisualStateManager.GoToState(this, "Unfocused", false);
       }
</code></pre></div><p>This example is shown in operation in the <a href="https://www.w3.org/WAI/WCAG20/Techniques/working-examples/SL7/FocusVisualCustomControlTestPage.html">
                    working example of Visual Focus Indicator</a>.</p></div></div><h2 id="SL7-resources">参考リソース</h2><div class="textbody"><p>この参考リソースは、あくまでも情報提供のみが目的であり、推薦などを意味するものではない。</p><ul><li><p>
                  <a href="https://msdn.microsoft.com/en-us/library/cc189093(VS.95).aspx">Customizing
    					the Appearance of an Existing Control by Using a ControlTemplate</a> 
               </p></li><li><p>
                  <a href="https://msdn.microsoft.com/en-us/library/cc903954(VS.95).aspx">Focus
    						Overview</a> 
               </p></li></ul></div><h2 id="SL7-related-techs">関連する達成方法</h2><div class="textbody"><ul><li><a href="SCR31.html">SCR31: フォーカスのある要素の背景色又はボーダーを変更するために、スクリプトを使用する</a></li></ul></div><h2 id="SL7-tests">検証</h2><div class="textbody"><h3 class="small-head" id="SL7-procedure">手順</h3><ol class="enumar"><li><p> Using a browser that supports Silverlight, open an HTML page that
    					references a Silverlight application through an object tag. </p></li><li><p> Using a keyboard, tab to the element where focus characteristics
    						are being examined. </p></li><li><p> Check that the background, border, or other noticable visual indicator
    							of the element changes color. </p></li><li><p> Check that the changes in color for the background, border, or
    								other noticable visual indicator are removed when the element loses
    								focus. </p></li></ol><h3 class="small-head" id="SL7-results">期待される結果</h3><p>#3 and #4 are true. </p><p>この達成方法が「十分な達成方法」の一つである場合、この手順や期待される結果を満たしていなければ、それはこの達成方法が正しく用いられていないことを意味するが、必ずしも達成基準を満たしていないことにはならない。場合によっては、別の達成方法によってその達成基準が満たされていることもありうる。</p></div><!-- BOTTOM NAVIGATION BAR --><ul id="navigationbottom"><li><strong><a href="#top">このページの先頭へ</a></strong></li><li><strong><a href="Overview.html#contents" title="Table of Contents">目次</a></strong></li><li><strong><a href="intro.html" title="Introduction to Techniques for WCAG 2.0"><abbr title="Introduction">イントロダクション</abbr></a></strong></li><li><a title="SL6: Defining a UI Automation Peer for a Custom Silverlight Control" href="SL6.html"><strong>前: </strong>
        達成方法 SL6</a></li><li><a title="SL8: Displaying HelpText in Silverlight User Interfaces" href="SL8.html"><strong>次: </strong>
        達成方法 SL8</a></li></ul><div class="footer"><p class="copyright">このウェブページは、<a href="Overview.html">WCAG 2.0 達成方法集: WCAG 2.0 の達成方法と失敗例</a> (<a href="https://www.w3.org/TR/WCAG20-TECHS/SL7.html">この文書の最新版 (英語)</a> を参照してください) の一部です。文書全体を<a href="complete.html">単一 HTML ファイルにしたもの</a>もご利用いただけます。この文書と、Web Content Accessibility Guidelines (WCAG) 2.0 に関連する他の文書との関係については、<a href="http://www.w3.org/WAI/intro/wcag20">The WCAG 2.0 Documents</a> をご覧ください。パブリックコメントを送るには、<a href="http://www.w3.org/WAI/WCAG20/comments/">Instructions for Commenting on WCAG 2.0 Documents</a> に従ってください。</p><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2016 <a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="http://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="http://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="http://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><p>【注意】 この文書は、W3C ワーキンググループノート <a href="https://www.w3.org/TR/2016/NOTE-WCAG20-TECHS-20161007/">Techniques for WCAG 2.0 の 2016 年 10 月 7 日時点での最新版</a>を<a href="https://waic.jp/committee/wg4/">ウェブアクセシビリティ基盤委員会 (WAIC)</a> が翻訳して公開しているものです。この文書の正式版は、W3C のサイトにある英語版です。正確な内容については、W3C が公開している原文 (英語) をご確認ください。この翻訳文書はあくまで参考情報であり、翻訳上の誤りが含まれていることがあります。翻訳上の誤りを見つけられた場合は、<a href="https://waic.jp/contact/">翻訳に関するお問い合わせ</a>からご連絡ください。</p><p>【重要】 達成方法のタイトルが英語のままになっているものは、日本語訳を行っていないため、原文 (英語) にリンクしています。</p></div></body></html>